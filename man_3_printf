.TH _printf 3 "Nov 2025" "Printf Project" "_printf Manual"

.SH NAME
_printf \- our version of the printf function.

.SH SYNOPSIS
.B #include "main.h"
.sp
.BI "int _printf(const char *" format ", ...);"

.SH DESCRIPTION
This is our attempt at building the standard C
.B printf
function from scratch. It takes a format string, scans it for '%' specifiers, and swaps them out with the arguments you pass in.

.SH HOW IT ACTUALLY WORKS
The whole thing is built around a loop that walks through the format string.
.PP
.B 1. The Hunt for '%':
The loop's main job is to find a '%' character. Everything that isn't a '%' is just plain text that gets printed directly.
.PP
.B 2. The Lookup Array:
The
.B prt_fun
array inside
.BR _printf.c.
It is like a dictionary that maps a character (like 's') to the specific function that knows how to handle it (like
.BR print_str).
.PP
.B 3. Calling the Right Function:
Once it finds a match in the array, it calls that function pointer, passing it the list of arguments. The handler function does its job, prints the thing, and returns how many characters it printed.
.PP
.B 4. The Buffer Strategy:
To improve performance, we don't call
.B write
for every single character. Instead, we use a local buffer of 1024 characters. Characters are added to this buffer, and
.B write
is only called when the buffer is full or when the function finishes execution.

.SH WHAT'S IMPLEMENTED
This is what we've built support for. If it's not on this list, it won't work.
.TP
.B %c
For single characters. Simple enough. (Uses
.BR print_char)
.TP
.B %s
For strings. (Uses
.BR print_str)
.TP
.B %d / %i
For integers. Right now, our code treats them as the exact same thing. (Both use
.BR print_int)
.TP
.B %%
For printing a literal '%' sign.i (Uses
.BR print_per)
.TP
.B %b
For unsigned integers. Converts the number to binary representation. (Uses
.BR print_binary)
.TP
.B %u
For unsigned integers. Prints the number without a sign. (Uses
.BR print_unsigned)
.TP
.B %o
For unsigned integers. Converts the number to octal representation. (Uses
.BR print_octal)
.TP
.B %x
For unsigned integers. Converts the number to hexadecimal representation using lowercase letters (a-f). (Uses
.BR print_hex)
.TP
.B %X
For unsigned integers. Converts the number to hexadecimal representation using uppercase letters (A-F). (Uses
.BR print_HEX)

.SH EXAMPLES
.B Strings and chars:
.sp
.RS
.nf
_printf("Character: %c, String: %s\n", 'A', "Hello");
.fi
.RE
.sp
.B Output:
.sp
.RS
.nf
Character: A, String: Hello
.fi
.RE
.sp
.B Digits:
.sp
.RS
.nf
_printf("The bill was $%d, and I only have $%i :(.", 23, 20);
.fi
.RE
.sp
.B Output:
.sp
.RS
.nf
The bill was $23, and I only have $20 :(.
.fi
.RE
.sp
.B Binary and Hex:
.sp
.RS
.nf
_printf("Binary: %b, Hex: %X\n", 98, 255);
.fi
.RE
.sp
.B Output:
.sp
.RS
.nf
Binary: 1100010, Hex: FF
.fi
.RE

.SH HOW TO ADD A NEW SPECIFIER
For when we need to add more types (like %b for binary or %p for pointers).
.IP "1." 3
Write the handler function in
.BR functions.c.
Remember, it
.B MUST
return the number of chars it printed.
.IP "2." 3
Add its prototype to
.BR main.h.
.IP "3." 3
Go to
.BR _printf.c
and add your new specifier to the
.B prt_fun
array. Just copy the format:
.BR {'b', print_binary},
.IP "4." 3
Update *this file*! Seriously. Add your new specifier to the list above so we don't lose track of what's been done.

.SH BUGS AND LIMITATIONS
.PP
This is a lightweight implementation and does not support all the features of the standard
.BR printf(3).
Key limitations include:
.IP "•" 4
.B No Flags:
Flags like
.BR +,
.BR -,
.BR #,
.B ' '
(space), and
.B 0
are not supported.
.IP "•" 4
.B No Width or Precision:
Specifying width (e.g.,
.BR %10s)
or precision (e.g.,
.BR %.2f)
has no effect.
.IP "•" 4
.B No Length Modifiers:
Length modifiers like
.B l
(for long) and
.B h
(for short) are not handled.
.IP "•" 4
.B Unknown Specifiers:
Passing an unsupported format specifier (e.g.,
.BR %r)
is currently ignored and %r will be printed literally.

.SH AUTHORS
Coded by: Mohammed Saeed Aldosari, Badriah Barakat Badriah.

.SH SEE ALSO
.BR printf(3), 
.BR write(2)
